---
title: 36道js手写题
date: 2021-04-07 11:10:10
permalink: /pages/8f20e1/
categories:
  - 前端
  - JavaScript文章
tags:
  - js
---
原文：[死磕 36 个 JS 手写题（搞懂后，提升真的大）](https://juejin.cn/post/6946022649768181774#heading-45)

## `JS`数据类型判断

`typeof` 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 `typeof `来判断数据类型会不准确。但是可以使用 `Object.prototype.toString` 实现。

```js
function typeOf(obj) {
    let res = Object.prototype.toString.call(obj).split(' ')[1]
    res = res.substring(0, res.length - 1).toLowerCase()
    return res
}
typeOf([])        // 'array'
typeOf({})        // 'object'
typeOf(new Date)  // 'date'

```

## 继承（没咋看懂）

### 原型链继承

```js
function Animal() {
    this.colors = ['black', 'white']
}
Animal.prototype.getColor = function() {
    return this.colors
}
function Dog() {}
Dog.prototype =  new Animal()

let dog1 = new Dog()
dog1.colors.push('brown')
let dog2 = new Dog()
console.log(dog2.colors)  // ['black', 'white', 'brown']
```

原型链继承存在的问题：

- 问题1：原型中包含的引用类型属性将被所有实例共享；
- 问题2：子类在实例化的时候不能给父类构造函数传参；

### 借用构造函数实现继承

```js
function Animal(name) {
    this.name = name
    this.getName = function() {
        return this.name
    }
}
function Dog(name) {
    Animal.call(this, name)
}
Dog.prototype =  new Animal()

```

借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。

### 组合继承

组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。

```js
function Animal(name) {
    this.name = name
    this.colors = ['black', 'white']
}
Animal.prototype.getName = function() {
    return this.name
}
function Dog(name, age) {
    Animal.call(this, name)
    this.age = age
}
Dog.prototype =  new Animal()
Dog.prototype.constructor = Dog

let dog1 = new Dog('奶昔', 2)
dog1.colors.push('brown')
let dog2 = new Dog('哈赤', 1)
console.log(dog2) 
// { name: "哈赤", colors: ["black", "white"], age: 1 }

```

### 寄生式组合继承

组合继承已经相对完善了，但还是存在问题，它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。

所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。

寄生式组合继承写法上和组合继承基本类似，区别是如下这里：

```diff
- Dog.prototype =  new Animal()
- Dog.prototype.constructor = Dog

+ function F() {}
+ F.prototype = Animal.prototype
+ let f = new F()
+ f.constructor = Dog
+ Dog.prototype = f

```

稍微封装下上面添加的代码后：

```js
function object(o) {
    function F() {}
    F.prototype = o
    return new F()
}
function inheritPrototype(child, parent) {
    let prototype = object(parent.prototype)
    prototype.constructor = child
    child.prototype = prototype
}
inheritPrototype(Dog, Animal)

```

如果你嫌弃上面的代码太多了，还可以基于组合继承的代码改成最简单的寄生式组合继承：

```diff
- Dog.prototype =  new Animal()
- Dog.prototype.constructor = Dog

+ Dog.prototype =  Object.create(Animal.prototype)
+ Dog.prototype.constructor = Dog

```

### class实现继承

```js
class Animal {
    constructor(name) {
        this.name = name
    } 
    getName() {
        return this.name
    }
}
class Dog extends Animal {
    constructor(name, age) {
        super(name)
        this.age = age
    }
}

```

## 数组去重

`ES5`实现：

```js
function unique(arr) {
    var res = arr.filter(function(item, index, array) {
        return array.indexOf(item) === index
    })
    return res
}
```

`ES6`实现：

```js
var unique = arr => [...new Set(arr)]
```

Set是ES6新提供的数据结构，**类似于数组，但是本身没有重复值。**

## 数组扁平化

数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层：

```js
[1, [2, [3]]].flat(2)  // [1, 2, 3]
```

现在就是要实现 flat 这种效果。

ES5 实现：递归。

```js
function flatten(arr) {
    var result = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        if (Array.isArray(arr[i])) {
            result = result.concat(flatten(arr[i]))
        } else {
            result.push(arr[i])
        }
    }
    return result;
}
```

ES6实现：

```js
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr);
    }
    return arr;
}
```

es6的扩展运算符能将二维数组变为一维。

根据这个结果我们可以做一个遍历，若arr中含有数组则使用一次扩展运算符，直至没有为止。

## 深浅拷贝

浅拷贝：只考虑对象类型。

```js
function shallowCopy(obj) {
    if (typeof obj !== 'object') return
    
    let newObj = obj instanceof Array ? [] : {}
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = obj[key]
        }
    }
    return newObj
}
```

简单版深拷贝：只考虑普通对象属性，不考虑内置对象和函数。

```js
function deepClone(obj) {
    // 不是object类型不拷贝
    if (typeof obj !== 'object') return;
    var newObj = obj instanceof Array ? [] : {};
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            // 判断子元素类型是否是object，是则将子元素递归，否则直接赋值
            newObj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key];
        }
    }
    return newObj;
}
```

复杂版深克隆：基于简单版的基础上，还考虑了内置对象比如 Date、RegExp 等对象和函数以及解决了循环引用的问题。

```js
const isObject = (target) => (typeof target === "object" || typeof target === "function") && target !== null;

function deepClone(target, map = new WeakMap()) {
    if (map.get(target)) {
        return target;
    }
    // 获取当前值的构造函数：获取它的类型
    let constructor = target.constructor;
    // 检测当前对象target是否与正则、日期格式对象匹配
    if (/^(RegExp|Date)$/i.test(constructor.name)) {
        // 创建一个新的特殊对象(正则类/日期类)的实例
        return new constructor(target);  
    }
    if (isObject(target)) {
        map.set(target, true);  // 为循环引用的对象做标记
        const cloneTarget = Array.isArray(target) ? [] : {};
        for (let prop in target) {
            if (target.hasOwnProperty(prop)) {
                cloneTarget[prop] = deepClone(target[prop], map);
            }
        }
        return cloneTarget;
    } else {
        return target;
    }
}
```

## 解析 URL 参数为对象（还没看）

```js
function parseParam(url) {
    // 将 ? 后面的字符串取出来
    const paramsStr = /.+\?(.+)$/.exec(url)[1]; 
    // 将字符串以 & 分割后存到数组中
    const paramsArr = paramsStr.split('&'); 
    let paramsObj = {};
    // 将 params 存到对象中
    paramsArr.forEach(param => {
        // 处理有 value 的参数
        if (/=/.test(param)) { 
            // 分割 key 和 value
            let [key, val] = param.split('='); 
            // 解码
            val = decodeURIComponent(val); 
            // 判断是否转为数字
            val = /^\d+$/.test(val) ? parseFloat(val) : val; 
    		// 如果对象有 key，则添加一个值
            if (paramsObj.hasOwnProperty(key)) { 
                paramsObj[key] = [].concat(paramsObj[key], val);
            } else { // 如果对象没有这个 key，创建 key 并设置值
                paramsObj[key] = val;
            }
        } else { // 处理没有 value 的参数
            paramsObj[param] = true;
        }
    })
    
    return paramsObj;
}
```

## 字符串模板（还没看）

```js
function render(template, data) {
    // 模板字符串正则
    const reg = /\{\{(\w+)\}\}/; 
    // 判断模板里是否有模板字符串
    if (reg.test(template)) { 
        // 查找当前模板里第一个模板字符串的字段
        const name = reg.exec(template)[1]; 
        // 将第一个模板字符串渲染
        template = template.replace(reg, data[name]); 
        // 递归的渲染并返回渲染后的结构
        return render(template, data); 
    }
    // 如果模板没有模板字符串直接返回
    return template; 
}
```

## 图片懒加载（还没看）

与普通的图片懒加载不同，如下这个多做了 2 个精心处理：

- 图片全部加载完成后移除事件监听；
- 加载完的图片，从 imgList 移除；

```diff
let imgList = [...document.querySelectorAll('img')]
let length = imgList.length

const imgLazyLoad = function() {
    let count = 0
    // 修正错误，需要加上自执行
-   return function() {
+   return (function() {
        let deleteIndexList = []
        imgList.forEach((img, index) => {
            let rect = img.getBoundingClientRect()
            if (rect.top < window.innerHeight) {
                img.src = img.dataset.src
                deleteIndexList.push(index)
                count++
                if (count === length) {
                    document.removeEventListener('scroll', imgLazyLoad)
                }
            }
        })
        imgList = imgList.filter((img, index) => !deleteIndexList.includes(index))
-   }
+   })()
}

// 这里最好加上防抖处理
document.addEventListener('scroll', imgLazyLoad)
```

参考：[图片懒加载](https://juejin.cn/post/6844903856489365518#heading-19)

## 函数防抖

触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。

简单版：函数内部支持使用 this 和 event 对象；

```js
function debounce(func, wait) {
    var timeout;
    return function () {
        // 修正this指向window的问题
        var context = this;
        // 解决函数的事件对象 event 变成了 undeined的问题
        var args = arguments;
        clearTimeout(timeout)
        timeout = setTimeout(function () {
            // 传入参数
            func.apply(context, args)
        }, wait)
    }
}
```

使用：

```js
var node = document.getElementById('layout')
function getUserAction(e) {
    console.log(this, e)  // 分别打印：node 这个节点 和 MouseEvent
    node.innerHTML = count++;
};
node.onmousemove = debounce(getUserAction, 1000)

```

最终版：除了支持 this 和 event 外，还支持以下功能：

- 支持立即执行；
- 函数可能有返回值；
- 支持取消功能；

```js
function debounce(func, wait, immediate) {
    var timeout, result;
    
    var debounced = function () {
        var context = this;
        var args = arguments;
        
        if (timeout) clearTimeout(timeout);
        if (immediate) {
            // 如果已经执行过，不再执行
            var callNow = !timeout;
            timeout = setTimeout(function(){
                timeout = null;
            }, wait)
            if (callNow) result = func.apply(context, args)
        } else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
        return result;
    };

    debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = null;
    };

    return debounced;
}
```

使用：

```js
var setUseAction = debounce(getUserAction, 10000, true);
// 使用防抖
node.onmousemove = setUseAction

// 取消防抖
setUseAction.cancel()
```

## 函数节流

>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。也就是一个函数执行一次后，只有大于设定的执行周期后才会执行第二次。
>记忆法：联系到水流的流量，我想让你1s只流出多少水你就只能流多少水，多的水流只能等到下个周期才能流出。
>应用场景：如用户不断滑动滚轮，规定1s只能真正下滑一次，你滑再多也没用，只能等到下个周期你再滑才有用。

### 实现原理：

A：用函数的闭包来锁住上一执行的时间，在用这一次执行的时间相比，大于设定的间隔时间则执行
B：也可以直接把lasTime放到全局去，不用闭包但这样就不好在事件监听的时候传递参数delay只能写死

### 避免this的指向丢失：

1.throttle函数在全局执行，内部this通常是指向window的，然后返回一个匿名函数。
2.返回的匿名函数绑定了事件，this指向监听的元素（document）
3.fn如果直接用fn()这样的函数调用模式，this是绑定到全局的（非严格模式下），这里需要特殊处理
4这里用apply修正this指向，使fn内部的this重新指向document

```js
<script type="text/javascript">
            function throttle(fn, delay) {
                console.log(this)//window
                // 记录上一次函数触发的时间
                var lastTime = 0;
                return function() {
                    // 记录当前函数触发的时间
                    var nowTime = Date.now();
                    if(nowTime - lastTime > delay) {
                     /*
                          fn();
                        console.log(this)//document
                    */
                        
                        fn.apply(this)// 修正this指向问题
                        console.log(this)//document
                        
                        // 同步时间
                        lastTime = nowTime;
                    }
                }
            }
            document.onscroll = throttle(function() {
                /*console.log(this)//window*/
                console.log(this)//document
                console.log('scroll事件被触发了' + Date.now())
            }, 1000)
</script>
```

## 函数柯里化

### 什么是柯里化

柯里化，是函数式编程的一个重要概念。它既能减少代码冗余，也能增加可读性。另外，附带着还能用来装逼。

先给出柯里化的定义：在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

柯里化的定义，理解起来有点费劲。为了更好地理解，先看下面这个例子：

```js
function add (a, b, c) {
    console.log(a + b + c);
}
add(1, 2, 3); // 6
```

add函数的柯里化函数_add则可以如下：

```javascript
function _add(a) {
    return function(b) {
        return function(c) {
            return a + b + c;
        }
    }
}
```

下面的运算方式是等价的。

```javascript
add(1, 2, 3); // 6
_add(1)(2)(3); // 6
```

### 柯里化的实现

```javascript
// 简单实现，参数只能从右到左传递
function createCurry(func, args) {
	// 函数参数的长度
    var arity = func.length;
    // 用来存放上一层收集的参数（第一次调用没有参数所以赋值为空数组）
    var args = args || [];

    return function() {
        // 收集参数
        var _args = [].slice.call(arguments);
        // 添加上一层传递的参数
        [].push.apply(_args, args);

        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数
        if (_args.length < arity) {
            return createCurry.call(this, func, _args);
        }

        // 参数收集完毕，则执行func
        return func.apply(this, _args);
    }
}
```

这个createCurry函数的封装借助闭包与递归，实现了一个参数收集，并在收集完毕之后执行所有参数的一个过程。

