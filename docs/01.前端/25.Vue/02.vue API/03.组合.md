---
title: 组合
date: 2021-07-09 15:31:13
permalink: /pages/7a1607/
categories:
  - 前端
  - Vue
  - vue API
tags:
  - vue
---

# 组合

### parent

- **类型**：<span style="color:#d63200">Vue instance</span>

- **详细**：

  指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 `this.$parent` 访问父实例，子实例被推入父实例的 `$children` 数组中。

- 参考：我的另一篇[组件通信之 $parent 和 $children](https://ctrlwin.github.io/blog/pages/24ce64/)

::: warning

节制地使用 `$parent` 和 `$children` - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信

:::

<!-- more -->

### mixins

- **类型**：<span style="color:#d63200">Array\<Object\></span>

- **详细**：

  `mixins` 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 `Vue.extend()` 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。

  Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。

* 示例

  ```js
  var mixin = {
    created: function () { console.log(1) }
  }
  
  var vm = new Vue({
    created: function () { console.log(2) },
    mixins: [mixin]  // 通过将混入对象放入mixins数组中，使其在组件中可以被使用
  })
  // => 1
  // => 2
  ```

### extends

- **类型**：<span style="color:#d63200">Object | Function</span>

- **详细**：

  允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 `Vue.extend`。这主要是为了便于扩展单文件组件。

  这和 `mixins` 类似。

  ```js
  var CompA = { ... }
  
  // 在没有调用 `Vue.extend` 时候继承 CompA
  var CompB = {
    extends: CompA,
    ...
  }
  ```

### provide / inject

- **类型**：

  - **provide**：<span style="color:#d63200">Object | () => Object</span>
  - **inject**：<span style="color:#d63200">Array\<string\> | { [key: string]: string | Symbol | Object }</span>

- **详细**：

  这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。

  `provide` 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 `Symbol` 和 `Reflect.ownKeys` 的环境下可工作。

  `inject` 选项应该是：

  - 一个字符串数组，或
  - 一个对象，对象的 key 是本地的绑定名，value 是：
    - 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或
    - 一个对象，该对象的：
      - `from` property 是在可用的注入内容中搜索用的 key (字符串或 Symbol)
      - `default` property 是降级情况下使用的 value

  > 提示：`provide` 和 `inject` 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。

* 参考：我的另一篇[组件通信之 provide / inject](https://ctrlwin.github.io/blog/pages/0a5b2b/)