---
title: provide 和 inject
date: 2021-07-27 14:24:22
permalink: /pages/0a5b2b/
categories:
  - 前端
  - Vue
tags:
  - 
---
# provide 和 inject

## 概念

**成对出现：**provide和inject是成对出现的

**作用**：用于父组件向子孙组件传递数据

**使用方法：**provide在父组件中返回要传给下级的数据，inject在需要使用这个数据的子辈组件或者孙辈等下级组件中注入数据。

**使用场景：**由于vue有$parent属性可以让子组件访问父组件。但孙组件想要访问祖先组件就比较困难。通过provide/inject可以轻松实现**跨级访问祖先组件**的数据。

<!-- more -->

## 定义

`provide` 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 `Symbol` 和 `Reflect.ownKeys` 的环境下可工作。

`inject` 选项应该是：

- 一个字符串数组，或
- 一个对象，对象的 key 是本地的绑定名，value 是：
  - 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或
  - 一个对象，该对象的：
    - `from` property 是在可用的注入内容中搜索用的 key (字符串或 Symbol)
    - `default` property 是降级情况下使用的 value

::: warning
提示：`provide` 和 `inject` 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。
:::

　provide/inject：简单的来说就是在父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。

​	需要注意的是这里不论子组件有多深，只要调用了inject那么就可以注入provide中的数据。而不是局限于只能从当前父组件的prop属性来获取数据。

**示例：**

下面是一个常见的使用方式：

```vue
<template>
  <div
    id="app"
  >
    <router-view
      v-if="isRouterAlive"
    />
  </div>
</template>

<script>
export default {
  name: 'App',
  components: {
    MergeTipDialog,
    BreakNetTip
  },
  data () {
    return {
      isShow: false,
      isRouterAlive: true
  },
  // 父组件中返回要传给下级的数据
  provide () {
    return {
      reload: this.reload
    }
  },
  methods: {
    reload () {
      this.isRouterAlive = false
      this.$nextTick(() => {
        this.isRouterAlive = true
      })
    }
  }
 }
</script>
```

``` js
// 子孙组件接收父组件传递的方法
export default {
//引用vue reload方法
  inject: ['reload'],
methods: {
    async successHandle () {
      this.reload()
    }
  }
}
```

这样就实现了子组件调取reload方法就实现了刷新vue组件的功能。
