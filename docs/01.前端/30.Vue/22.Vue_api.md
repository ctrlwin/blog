---
title: Vue_api
date: 2021-07-09 15:31:13
permalink: /pages/82287c/
categories:
  - 前端
  - Vue文章
tags:
  - vue
---
## 全局api

###  Vue.extend(options)

- **参数**：

  - <span style="color:#d63200">{Object} options</span>

- **用法**：

  使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

  `data` 选项是特例，需要注意 - 在 `Vue.extend()` 中它必须是函数

<!-- more -->

  ```html
  <div id="mount-point"></div>
  ```

  ```js
  // 创建构造器
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Walter',
        lastName: 'White',
        alias: 'Heisenberg'
      }
    }
  })
  // 创建 Profile 实例，并挂载到一个元素上。
  new Profile().$mount('#mount-point')
  ```

  结果如下：

  ```html
  <p>Walter White aka Heisenberg</p>
  ```

### Vue.nextTick([callback,context])

- **参数**：
  - <span style="color:#d63200">{Function} [callback]</span>
  - <span style="color:#d63200">{Object | Array} target</span>
- **用法**：

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

```js

    testClick(){
      this.testMsg="修改后的值";
      this.$nextTick(function(){
        console.log(that.$refs.aa.innerText);  //输出：修改后的值
      });
    }
```

注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。`$nextTick` 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 `$nextTick`，则可以在回调中获取更新后的 DOM

* 作为一个Promise使用

``` js
Vue.nextTick()
  .then(function () {
    // DOM 更新了
  })
```

* 什么时候需要用到`Vue.nextTick()`？

1. 当你需要在Vue的生命周期**created()钩子函数中进行DOM操作时**，一定要将操作放在`Vue.nextTick()`的回调函数中。原因是在`created()`钩子函数执行时DOM还未渲染，此时是获取不到DOM的，这时候就需要用到`Vue.nextTick()`方法了。

```js
created(){
    this.$nextTick(function(){  //不使用this.$nextTick()方法会报错
   		 that.$refs.aa.innerHTML="created中更改了按钮内容";  //写入到DOM元素
    });
},
```

2. 当项目中你想在**改变DOM元素的数据后**基于新的dom做点什么，**对新DOM一系列的js操作都需要放进`Vue.nextTick()`的回调函数中；**通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它

```js
changeTxt(){
    this.testMsg="修改后的文本值";
    this.$nextTick(function(){  //使用vue.$nextTick()方法可以dom数据更新后延迟执行
        let domTxt=document.getElementById('h').innerText; 
        console.log(domTxt);  // 如果不使用nextTick()方法这里打印的是原始值而不是修改后的值
    });
},
```

* `Vue.nextTick()` 使用原理

原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOM操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。

当你设置 `vm.someData = 'new value'`，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用` Vue.nextTick(callback)` 。这样回调函数在 DOM 更新完成后就会调用。

### Vue.set(target, propertyName/index, value)

- **参数**：

  - <span style="color:#d63200">{Object | Array} target</span>
  - <span style="color:#d63200">{string | number} propertyName/index</span>
  - <span style="color:#d63200">{any} value</span>

- **返回值**：设置的值。

- **用法**：

  向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 `this.myObject.newProperty = 'hi'`)

```js
// 数组 items: ["a", "b", "d", "123"],
// 更改数组第一位的值
this.$set(this.items, 0, "value") // ["value", "b", "d", "123"]
// 给数组添加值
this.$set(this.item, 4, "value") // ["a", "b", "d", "123", "value"]
// 对象同理
```

::: warning

对象不能是 Vue 实例，或者 Vue 实例的根数据对象。

:::

### Vue.delete(target, propertyName/index)

**参数**：

- <span style="color:#d63200">{Object | Array} target</span>
- <span style="color:#d63200">{string | number} propertyName/index</span>

**用法**：

删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。

```js
// 数组 items: ["a", "b", "d"]
this.$delete(this.items, 0) // ["b", "d"]
```



::: danger

目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。

:::

### Vue.directive(id, [definition])

- **参数**：

  - <span style="color:#d63200">{string} id</span>
  - <span style="color:#d63200">{Function | Object} [definition]</span>

- **用法**：

  注册或获取全局指令。

  ```js
  // 注册
  Vue.directive('my-directive', {
      // 生命周期
    bind: function () {},
    inserted: function () {},
    update: function () {},
    componentUpdated: function () {},
    unbind: function () {}
  })
  
  // 注册 (指令函数)
  Vue.directive('my-directive', function () {
    // 这里将会被 `bind` 和 `update` 调用
  })
  
  // getter，返回已注册的指令
  var myDirective = Vue.directive('my-directive')
  ```

  局部注册：

  ```js
  directives: {
    focus: {
      // 指令的定义
      inserted: function (el) {
        el.focus()
      }
    }
  }
  
  // 然后可以在模板中任意元素上使用：v-focus
  ```

  

* 钩子函数
  * `bind` ：只调用一次，指令第一次绑定到元素时候调用，用这个钩子可以定义一个绑定时执行一次的初始化动作。
  * `inserted`：被绑定的元素插入父节点的时候调用(父节点存在即可调用，不必存在document中)
  * `update`：被绑定与元素所在模板更新时调用，而且无论绑定值是否有变化，通过比较更新前后的绑定值，忽略不必要的模板更新。
  * `componentUpdate`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。
  * `unbind`：只调用一次，指令元素解绑的时候调用。

- **参考**：[自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)

### Vue.filter(id, [definition])

- **参数**：

  - <span style="color:#d63200">{string} id</span>
  - <span style="color:#d63200">{Function} [definition]</span>

- **用法**：

  注册或获取全局过滤器。

```js
// 注册
Vue.filter('my-filter', function (value) {
  // 返回处理后的值
})

// getter，返回已注册的过滤器
var myFilter = Vue.filter('my-filter')
```

- **参考**：[过滤器](https://cn.vuejs.org/v2/guide/filters.html)
- 也可以参考我的另一篇文章[filters过滤器的使用](https://ctrlwin.github.io/blog/pages/778426/#%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8)

### Vue.component(id, [definition])

- **参数**：

  - <span style="color:#d63200">{string} id</span>
  - <span style="color:#d63200">{Function | Object} [definition]</span>

- **用法**：

  注册或获取全局组件。注册还会自动使用给定的 `id` 设置组件的名称

  ```js
  // 注册组件，传入一个扩展过的构造器
  Vue.component('my-component', Vue.extend({ /* ... */ }))
  
  // 注册组件，传入一个选项对象 (自动调用 Vue.extend)
  Vue.component('my-component', { /* ... */ })
  
  // 获取注册的组件 (始终返回构造器)
  var MyComponent = Vue.component('my-component')
  ```

### Vue.use(plugin)

- **参数**：

  - <span style="color:#d63200">{Object | Function} plugin</span>

- **用法**：

  安装 Vue.js 插件。如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。

  该方法需要在调用 `new Vue()` 之前被调用。

  当 install 方法被同一个插件多次调用，插件将只会被安装一次。

- **参考**：[插件](https://cn.vuejs.org/v2/guide/plugins.html)

### Vue.mixin(mixin)

- **参数**：

  - <span style="color:#d63200">{Object} mixin</span>

- **用法**：

  全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。**不推荐在应用代码中使用**。

- **参考**：[全局混入](https://cn.vuejs.org/v2/guide/mixins.html#全局混入)

* 也可以参考我的另一篇文章[mixin的使用](https://ctrlwin.github.io/blog/pages/923b09/)

### Vue.compile(template)

* 参数：
  * <span style="color:#d63200">{string} template</span>

* 用法：

  将一个模板字符串编译成 render 函数。

  ```js
  var res = Vue.compile('<div><span>{{ msg }}</span></div>')
  
  new Vue({
    data: {
      msg: 'hello'
    },
    render: res.render,
    staticRenderFns: res.staticRenderFns
  })
  ```


* **参考**：[渲染函数](https://cn.vuejs.org/v2/guide/render-function.html)

### Vue.observable(object)

- **参数**：

  - <span style="color:#d63200">{Object} object</span>

- **用法**：

  让一个对象可响应。Vue 内部会用它来处理 `data` 函数返回的对象。

  返回的对象可以直接用于[渲染函数](https://cn.vuejs.org/v2/guide/render-function.html)和[计算属性](https://cn.vuejs.org/v2/guide/computed.html)内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：

```js
const state = Vue.observable({ count: 0 })

const Demo = {
  render(h) {
    return h('button', {
      on: { click: () => { state.count++ }}
    }, `count is: ${state.count}`)
  }
}
```

::: warning

在 Vue 2.x 中，被传入的对象会直接被 `Vue.observable` 变更，所以如[这里展示的](https://cn.vuejs.org/v2/guide/instance.html#数据与方法)，它和被返回的对象是同一个对象。在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的。因此，为了向前兼容，我们推荐始终操作使用 `Vue.observable` 返回的对象，而不是传入源对象。

:::

- **参考**：[深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html)

## 数据

### data

- **类型**：<span style="color:#d63200">Object | Function</span>

- **限制**：组件的定义只接受 `function`。

- **详细**：

  Vue 实例的数据对象。Vue 会递归地把 data 的 property 转换为 getter/setter，从而让 data 的 property 能够响应数据变化。**对象必须是纯粹的对象 (含有零个或多个的 key/value 对)**：浏览器 API 创建的原生对象，原型上的 property 会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。

### props

- **类型**：<span style="color:#d63200">Array \<string> | Object</span>

- **详细**：

  props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。

  你可以基于对象的语法使用以下选项：

  - <span style="color:#d63200">type</span>：可以是下列原生构造函数中的一种：<span style="color:#d63200">String</span>、<span style="color:#d63200">Number</span>、<span style="color:#d63200">Boolean</span>、<span style="color:#d63200">Array</span>、<span style="color:#d63200">Object</span>、<span style="color:#d63200">Date</span>、<span style="color:#d63200">Function</span>、<span style="color:#d63200">Symbol</span>、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的[更多信息在此](https://cn.vuejs.org/v2/guide/components-props.html#Prop-类型)。
  - <span style="color:#d63200">default : any</span>
    为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。
  - <span style="color:#d63200">require : Boolean</span>
    定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。
  - <span style="color:#d63200">validator : Function</span>
    自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在[这里](https://cn.vuejs.org/v2/guide/components-props.html#Prop-验证)查阅更多 prop 验证的相关信息
  
- **prop验证：**

  ```js
  Vue.component('my-component', {
    props: {
      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
      propA: Number,
      // 多个可能的类型
      propB: [String, Number],
      // 必填的字符串
      propC: {
        type: String,
        required: true
      },
      // 带有默认值的数字
      propD: {
        type: Number,
        default: 100
      },
      // 带有默认值的对象
      propE: {
        type: Object,
        // 对象或数组默认值必须从一个工厂函数获取
        default: function () {
          return { message: 'hello' }
        }
      },
      // 自定义验证函数
      propF: {
        validator: function (value) {
          // 这个值必须匹配下列字符串中的一个
          return ['success', 'warning', 'danger'].indexOf(value) !== -1
        }
      }
    }
  })
  ```

  ::: warning

  prop 会在一个组件实例创建**之前**进行验证，所以实例的 property (如 `data`、`computed` 等) 在 `default` 或 `validator` 函数中是不可用的。

  :::

- **参考**：[Props](https://cn.vuejs.org/v2/guide/components-props.html)

### computed

- **类型**：<span style="color:#d63200">{ [key: string]: Function | { get: Function, set: Function } }</span>

- **详细**：

  计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。

  注意如果你为一个计算属性使用了箭头函数，则 `this` 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。

  ```vue
  computed: {
    aDouble: vm => vm.a * 2
  }
  ```

  计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算（<span style="color:#000000;font-weight:500;">简单说就是只有computed依赖的变量改变，computed才会更新</span>）。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是**不会**被更新的。

- **参考**：[计算属性](https://cn.vuejs.org/v2/guide/computed.html)

### methods

- **类型**：<span style="color:#d63200">{ [key: string]: Function }</span>

- **详细**：

  methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 `this` 自动绑定为 Vue 实例。

  ::: warning

  **不应该使用箭头函数来定义 method 函数** (例如 `plus: () => this.a++`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.a` 将是 undefined。

  :::

- **参考**：[事件处理器](https://cn.vuejs.org/v2/guide/events.html)

### watch

- **类型**：<span style="color:#d63200">{ [key: string]: string | Function | Object | Array }</span>

- **详细**：

  一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 `$watch()`，遍历 watch 对象的每一个 property。

  ::: warning

  **不应该使用箭头函数来定义 watcher 函数** (例如 `searchQuery: newValue => this.updateAutocomplete(newValue)`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.updateAutocomplete` 将是 undefined。

  :::

- **参考**：[实例方法 / 数据 - vm.$watch](https://cn.vuejs.org/v2/api/?#vm-watch)

## 生命周期

### beforeCreate

- **类型**：<span style="color:#d63200">Function</span>

- **详细**：

  在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。

### created

- **类型**：<span style="color:#d63200">Function</span>

- **详细**：

  在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，`$el` property 目前尚不可用。

### beforeMount

- **类型**：<span style="color:#d63200">Function</span>

- **详细**：

  在挂载开始之前被调用：相关的 `render` 函数首次被调用。

### mounted

- **类型**：<span style="color:#d63200">Function</span>

- **详细**：

  实例被挂载后调用，这时 `el` 被新创建的 `vm.$el` 替换了。如果根实例挂载到了一个文档内的元素上，当 `mounted` 被调用时 `vm.$el` 也在文档内。

### beforeUpdate

- **类型**：<span style="color:#d63200">Function</span>

- **详细**：

  数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。

### updated

- **类型**：<span style="color:#d63200">Function</span>

- **详细**：

  由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。

  当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用[计算属性](https://cn.vuejs.org/v2/api/?#computed)或 [watcher](https://cn.vuejs.org/v2/api/?#watch) 取而代之。

  注意 `updated` **不会**保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 `updated` 里使用 [vm.$nextTick](https://cn.vuejs.org/v2/api/?#vm-nextTick)：

### activated

- **类型**：<span style="color:#d63200">Function</span>

- **详细**：

  被 keep-alive 缓存的组件激活时调用。

### deactivated

- **类型**：<span style="color:#d63200">Function</span>

- **详细**：

  被 keep-alive 缓存的组件停用时调用。

### beforeDestroy

- **类型**：<span style="color:#d63200">Function</span>

- **详细**：

  实例销毁之前调用。在这一步，实例仍然完全可用。

### destroyed

- **类型**：<span style="color:#d63200">Function</span>

- **详细**：

  实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。

### errorCaptured

- **类型**：<span style="color:#d63200">(err: Error, vm: Component, info: string) => ?boolean</span>

- **详细**：

  当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 `false` 以阻止该错误继续向上传播。

### 生命周期图示

<img src="C:\Users\xin.long\Desktop\20181103212250917.png" />

## 组合

### parent

- **类型**：<span style="color:#d63200">Vue instance</span>

- **详细**：

  指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 `this.$parent` 访问父实例，子实例被推入父实例的 `$children` 数组中。

- 参考：我的另一篇[组件通信之 $parent 和 $children]()

::: warning

节制地使用 `$parent` 和 `$children` - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信

:::

### mixins

- **类型**：<span style="color:#d63200">Array\<Object\></span>

- **详细**：

  `mixins` 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 `Vue.extend()` 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。

  Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。

* 示例

  ```js
  var mixin = {
    created: function () { console.log(1) }
  }
  
  var vm = new Vue({
    created: function () { console.log(2) },
    mixins: [mixin]  // 通过将混入对象放入mixins数组中，使其在组件中可以被使用
  })
  // => 1
  // => 2
  ```

### extends

- **类型**：<span style="color:#d63200">Object | Function</span>

- **详细**：

  允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 `Vue.extend`。这主要是为了便于扩展单文件组件。

  这和 `mixins` 类似。

  ```js
  var CompA = { ... }
  
  // 在没有调用 `Vue.extend` 时候继承 CompA
  var CompB = {
    extends: CompA,
    ...
  }
  ```

### provide / inject

- **类型**：

  - **provide**：<span style="color:#d63200">Object | () => Object</span>
  - **inject**：<span style="color:#d63200">Array\<string\> | { [key: string]: string | Symbol | Object }</span>

- **详细**：

  这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。

  `provide` 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 `Symbol` 和 `Reflect.ownKeys` 的环境下可工作。

  `inject` 选项应该是：

  - 一个字符串数组，或
  - 一个对象，对象的 key 是本地的绑定名，value 是：
    - 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或
    - 一个对象，该对象的：
      - `from` property 是在可用的注入内容中搜索用的 key (字符串或 Symbol)
      - `default` property 是降级情况下使用的 value

  > 提示：`provide` 和 `inject` 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。

* 参考：我的另一篇[组件通信之 provide / inject]()

