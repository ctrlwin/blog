---
title: Vue_api
date: 2021-07-09 15:31:13
permalink: /pages/82287c/
categories:
  - 前端
  - Vue文章
tags:
  - vue
---
## 全局api

###  Vue.extend(options)

- **参数**：

  - <span style="color:#d63200">{Object} options</span>

- **用法**：

  使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

  `data` 选项是特例，需要注意 - 在 `Vue.extend()` 中它必须是函数

<!-- more -->

  ```html
  <div id="mount-point"></div>
  ```

  ```js
  // 创建构造器
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Walter',
        lastName: 'White',
        alias: 'Heisenberg'
      }
    }
  })
  // 创建 Profile 实例，并挂载到一个元素上。
  new Profile().$mount('#mount-point')
  ```

  结果如下：

  ```html
  <p>Walter White aka Heisenberg</p>
  ```

### Vue.nextTick([callback,context])

- **参数**：
  - <span style="color:#d63200">{Function} [callback]</span>
  - <span style="color:#d63200">{Object | Array} target</span>
- **用法**：

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

```js

    testClick(){
      this.testMsg="修改后的值";
      this.$nextTick(function(){
        console.log(that.$refs.aa.innerText);  //输出：修改后的值
      });
    }
```

注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。`$nextTick` 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 `$nextTick`，则可以在回调中获取更新后的 DOM

* 作为一个Promise使用

``` js
Vue.nextTick()
  .then(function () {
    // DOM 更新了
  })
```

* 什么时候需要用到`Vue.nextTick()`？

1. 当你需要在Vue的生命周期**created()钩子函数中进行DOM操作时**，一定要将操作放在`Vue.nextTick()`的回调函数中。原因是在`created()`钩子函数执行时DOM还未渲染，此时是获取不到DOM的，这时候就需要用到`Vue.nextTick()`方法了。

```js
created(){
    this.$nextTick(function(){  //不使用this.$nextTick()方法会报错
   		 that.$refs.aa.innerHTML="created中更改了按钮内容";  //写入到DOM元素
    });
},
```

2. 当项目中你想在**改变DOM元素的数据后**基于新的dom做点什么，**对新DOM一系列的js操作都需要放进`Vue.nextTick()`的回调函数中；**通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它

```js
changeTxt(){
    this.testMsg="修改后的文本值";
    this.$nextTick(function(){  //使用vue.$nextTick()方法可以dom数据更新后延迟执行
        let domTxt=document.getElementById('h').innerText; 
        console.log(domTxt);  // 如果不使用nextTick()方法这里打印的是原始值而不是修改后的值
    });
},
```

* `Vue.nextTick()` 使用原理

原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOM操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。

当你设置 `vm.someData = 'new value'`，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用` Vue.nextTick(callback)` 。这样回调函数在 DOM 更新完成后就会调用。

### Vue.set(target, propertyName/index, value)

- **参数**：

  - <span style="color:#d63200">{Object | Array} target</span>
  - <span style="color:#d63200">{string | number} propertyName/index</span>
  - <span style="color:#d63200">{any} value</span>

- **返回值**：设置的值。

- **用法**：

  向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 `this.myObject.newProperty = 'hi'`)

```js
// 数组 items: ["a", "b", "d", "123"],
// 更改数组第一位的值
this.$set(this.items, 0, "value") // ["value", "b", "d", "123"]
// 给数组添加值
this.$set(this.item, 4, "value") // ["a", "b", "d", "123", "value"]
// 对象同理
```

::: warning

对象不能是 Vue 实例，或者 Vue 实例的根数据对象。

:::

### Vue.delete(target, propertyName/index)

**参数**：

- <span style="color:#d63200">{Object | Array} target</span>
- <span style="color:#d63200">{string | number} propertyName/index</span>

**用法**：

删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。

```js
// 数组 items: ["a", "b", "d"]
this.$delete(this.items, 0) // ["b", "d"]
```



::: danger

目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。

:::

### Vue.directive(id, [definition])

- **参数**：

  - <span style="color:#d63200">{string} id</span>
  - <span style="color:#d63200">{Function | Object} [definition]</span>

- **用法**：

  注册或获取全局指令。

  ```js
  // 注册
  Vue.directive('my-directive', {
      // 生命周期
    bind: function () {},
    inserted: function () {},
    update: function () {},
    componentUpdated: function () {},
    unbind: function () {}
  })
  
  // 注册 (指令函数)
  Vue.directive('my-directive', function () {
    // 这里将会被 `bind` 和 `update` 调用
  })
  
  // getter，返回已注册的指令
  var myDirective = Vue.directive('my-directive')
  ```

  局部注册：

  ```js
  directives: {
    focus: {
      // 指令的定义
      inserted: function (el) {
        el.focus()
      }
    }
  }
  
  // 然后可以在模板中任意元素上使用：v-focus
  ```

  

* 钩子函数
  * `bind` ：只调用一次，指令第一次绑定到元素时候调用，用这个钩子可以定义一个绑定时执行一次的初始化动作。
  * `inserted`：被绑定的元素插入父节点的时候调用(父节点存在即可调用，不必存在document中)
  * `update`：被绑定与元素所在模板更新时调用，而且无论绑定值是否有变化，通过比较更新前后的绑定值，忽略不必要的模板更新。
  * `componentUpdate`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。
  * `unbind`：只调用一次，指令元素解绑的时候调用。

- **参考**：[自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)

### Vue.filter(id, [definition])

- **参数**：

  - <span style="color:#d63200">{string} id</span>
  - <span style="color:#d63200">{Function} [definition]</span>

- **用法**：

  注册或获取全局过滤器。

```js
// 注册
Vue.filter('my-filter', function (value) {
  // 返回处理后的值
})

// getter，返回已注册的过滤器
var myFilter = Vue.filter('my-filter')
```

- **参考**：[过滤器](https://cn.vuejs.org/v2/guide/filters.html)
- 也可以参考我的另一篇文章[filters过滤器的使用](https://ctrlwin.github.io/blog/pages/778426/#%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8)

### Vue.component(id, [definition])

- **参数**：

  - <span style="color:#d63200">{string} id</span>
  - <span style="color:#d63200">{Function | Object} [definition]</span>

- **用法**：

  注册或获取全局组件。注册还会自动使用给定的 `id` 设置组件的名称

  ```js
  // 注册组件，传入一个扩展过的构造器
  Vue.component('my-component', Vue.extend({ /* ... */ }))
  
  // 注册组件，传入一个选项对象 (自动调用 Vue.extend)
  Vue.component('my-component', { /* ... */ })
  
  // 获取注册的组件 (始终返回构造器)
  var MyComponent = Vue.component('my-component')
  ```

### Vue.use(plugin)

- **参数**：

  - <span style="color:#d63200">{Object | Function} plugin</span>

- **用法**：

  安装 Vue.js 插件。如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。

  该方法需要在调用 `new Vue()` 之前被调用。

  当 install 方法被同一个插件多次调用，插件将只会被安装一次。

- **参考**：[插件](https://cn.vuejs.org/v2/guide/plugins.html)

### Vue.mixin(mixin)

- **参数**：

  - <span style="color:#d63200">{Object} mixin</span>

- **用法**：

  全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。**不推荐在应用代码中使用**。

- **参考**：[全局混入](https://cn.vuejs.org/v2/guide/mixins.html#全局混入)

* 也可以参考我的另一篇文章[mixin的使用](https://ctrlwin.github.io/blog/pages/923b09/)

### Vue.compile(template)

* 参数：
  * <span style="color:#d63200">{string} template</span>

* 用法：

  将一个模板字符串编译成 render 函数。

  ```js
  var res = Vue.compile('<div><span>{{ msg }}</span></div>')
  
  new Vue({
    data: {
      msg: 'hello'
    },
    render: res.render,
    staticRenderFns: res.staticRenderFns
  })
  ```


* **参考**：[渲染函数](https://cn.vuejs.org/v2/guide/render-function.html)

### Vue.observable(object)

- **参数**：

  - <span style="color:#d63200">{Object} object</span>

- **用法**：

  让一个对象可响应。Vue 内部会用它来处理 `data` 函数返回的对象。

  返回的对象可以直接用于[渲染函数](https://cn.vuejs.org/v2/guide/render-function.html)和[计算属性](https://cn.vuejs.org/v2/guide/computed.html)内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：

```js
const state = Vue.observable({ count: 0 })

const Demo = {
  render(h) {
    return h('button', {
      on: { click: () => { state.count++ }}
    }, `count is: ${state.count}`)
  }
}
```

::: warning

在 Vue 2.x 中，被传入的对象会直接被 `Vue.observable` 变更，所以如[这里展示的](https://cn.vuejs.org/v2/guide/instance.html#数据与方法)，它和被返回的对象是同一个对象。在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的。因此，为了向前兼容，我们推荐始终操作使用 `Vue.observable` 返回的对象，而不是传入源对象。

:::

- **参考**：[深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html)

### Vue.version

- **细节**：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。

- **用法**：

  ```js
  var version = Number(Vue.version.split('.')[0])
  console.log(version) // 2
  ```

## 数据

### data

- **类型**：<span style="color:#d63200">Object | Function</span>

- **限制**：组件的定义只接受 `function`。

- **详细**：

  Vue 实例的数据对象。Vue 会递归地把 data 的 property 转换为 getter/setter，从而让 data 的 property 能够响应数据变化。**对象必须是纯粹的对象 (含有零个或多个的 key/value 对)**：浏览器 API 创建的原生对象，原型上的 property 会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。

### props

- **类型**：<span style="color:#d63200">Array \<string> | Object</span>

- **详细**：

  props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。

  你可以基于对象的语法使用以下选项：

  - <span style="color:#d63200">type</span>：可以是下列原生构造函数中的一种：<span style="color:#d63200">String</span>、<span style="color:#d63200">Number</span>、<span style="color:#d63200">Boolean</span>、<span style="color:#d63200">Array</span>、<span style="color:#d63200">Object</span>、<span style="color:#d63200">Date</span>、<span style="color:#d63200">Function</span>、<span style="color:#d63200">Symbol</span>、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的[更多信息在此](https://cn.vuejs.org/v2/guide/components-props.html#Prop-类型)。
  - <span style="color:#d63200">default : any</span>
    为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。
  - <span style="color:#d63200">require : Boolean</span>
    定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。
  - <span style="color:#d63200">validator : Function</span>
    自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在[这里](https://cn.vuejs.org/v2/guide/components-props.html#Prop-验证)查阅更多 prop 验证的相关信息
  
- **prop验证：**

  ```js
  Vue.component('my-component', {
    props: {
      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
      propA: Number,
      // 多个可能的类型
      propB: [String, Number],
      // 必填的字符串
      propC: {
        type: String,
        required: true
      },
      // 带有默认值的数字
      propD: {
        type: Number,
        default: 100
      },
      // 带有默认值的对象
      propE: {
        type: Object,
        // 对象或数组默认值必须从一个工厂函数获取
        default: function () {
          return { message: 'hello' }
        }
      },
      // 自定义验证函数
      propF: {
        validator: function (value) {
          // 这个值必须匹配下列字符串中的一个
          return ['success', 'warning', 'danger'].indexOf(value) !== -1
        }
      }
    }
  })
  ```

  ::: warning

  prop 会在一个组件实例创建**之前**进行验证，所以实例的 property (如 `data`、`computed` 等) 在 `default` 或 `validator` 函数中是不可用的。

  :::

- **参考**：[Props](https://cn.vuejs.org/v2/guide/components-props.html)

### computed

- **类型**：<span style="color:#d63200">{ [key: string]: Function | { get: Function, set: Function } }</span>

- **详细**：

  计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。

  注意如果你为一个计算属性使用了箭头函数，则 `this` 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。

  ```vue
  computed: {
    aDouble: vm => vm.a * 2
  }
  ```

  计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算（<span style="color:#000000;font-weight:500;">简单说就是只有computed依赖的变量改变，computed才会更新</span>）。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是**不会**被更新的。

- **参考**：[计算属性](https://cn.vuejs.org/v2/guide/computed.html)

### methods

- **类型**：<span style="color:#d63200">{ [key: string]: Function }</span>

- **详细**：

  methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 `this` 自动绑定为 Vue 实例。

  ::: warning

  **不应该使用箭头函数来定义 method 函数** (例如 `plus: () => this.a++`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.a` 将是 undefined。

  :::

- **参考**：[事件处理器](https://cn.vuejs.org/v2/guide/events.html)

### watch

- **类型**：<span style="color:#d63200">{ [key: string]: string | Function | Object | Array }</span>

- **详细**：

  一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 `$watch()`，遍历 watch 对象的每一个 property。

  ::: warning

  **不应该使用箭头函数来定义 watcher 函数** (例如 `searchQuery: newValue => this.updateAutocomplete(newValue)`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.updateAutocomplete` 将是 undefined。

  :::

- **参考**：[实例方法 / 数据 - vm.$watch](https://cn.vuejs.org/v2/api/?#vm-watch)

